// This file was generated by the Gtk# code generator.
// Any changes made will be lost if regenerated.

namespace Cdn {

	using System;
	using System.Runtime.InteropServices;

#region Autogenerated code
	public class Math {

		[DllImport("libcodyn-3.0.dll")]
		static extern bool cdn_math_function_is_variable(int type);

		public static bool FunctionIsVariable(Cdn.MathFunctionType type) {
			bool raw_ret = cdn_math_function_is_variable((int) type);
			bool ret = raw_ret;
			return ret;
		}

		[DllImport("libcodyn-3.0.dll")]
		static extern int cdn_math_function_lookup(IntPtr name, out int arguments);

		public static Cdn.MathFunctionType FunctionLookup(string name, out int arguments) {
			IntPtr native_name = GLib.Marshaller.StringToPtrGStrdup (name);
			int raw_ret = cdn_math_function_lookup(native_name, out arguments);
			Cdn.MathFunctionType ret = (Cdn.MathFunctionType) raw_ret;
			GLib.Marshaller.Free (native_name);
			return ret;
		}

		[DllImport("libcodyn-3.0.dll")]
		static extern bool cdn_math_function_is_commutative(int type, IntPtr argdim);

		public static bool FunctionIsCommutative(Cdn.MathFunctionType type, Cdn.StackArgs argdim) {
			bool raw_ret = cdn_math_function_is_commutative((int) type, argdim == null ? IntPtr.Zero : argdim.Handle);
			bool ret = raw_ret;
			return ret;
		}

		[DllImport("libcodyn-3.0.dll")]
		static extern IntPtr cdn_math_function_lookup_by_id(int type, out int arguments);

		public static string FunctionLookupById(Cdn.MathFunctionType type, out int arguments) {
			IntPtr raw_ret = cdn_math_function_lookup_by_id((int) type, out arguments);
			string ret = GLib.Marshaller.Utf8PtrToString (raw_ret);
			return ret;
		}

		[DllImport("libcodyn-3.0.dll")]
		static extern double cdn_math_constant_lookup(IntPtr name, out bool found);

		public static double ConstantLookup(string name, out bool found) {
			IntPtr native_name = GLib.Marshaller.StringToPtrGStrdup (name);
			double raw_ret = cdn_math_constant_lookup(native_name, out found);
			double ret = raw_ret;
			GLib.Marshaller.Free (native_name);
			return ret;
		}

		[DllImport("libcodyn-3.0.dll")]
		static extern unsafe bool cdn_math_function_get_stack_manipulation(int type, IntPtr inargs, IntPtr outarg, out int extra_space, out IntPtr error);

		public static unsafe bool FunctionGetStackManipulation(Cdn.MathFunctionType type, Cdn.StackArgs inargs, Cdn.StackArg outarg, out int extra_space) {
			IntPtr error = IntPtr.Zero;
			bool raw_ret = cdn_math_function_get_stack_manipulation((int) type, inargs == null ? IntPtr.Zero : inargs.Handle, outarg == null ? IntPtr.Zero : outarg.Handle, out extra_space, out error);
			bool ret = raw_ret;
			if (error != IntPtr.Zero) throw new GLib.GException (error);
			return ret;
		}

		[DllImport("libcodyn-3.0.dll")]
		static extern void cdn_math_function_execute(int type, IntPtr argdim, IntPtr stack);

		public static void FunctionExecute(Cdn.MathFunctionType type, Cdn.StackArgs argdim, Cdn.Stack stack) {
			cdn_math_function_execute((int) type, argdim == null ? IntPtr.Zero : argdim.Handle, stack == null ? IntPtr.Zero : stack.Handle);
		}

#endregion
	}
}
